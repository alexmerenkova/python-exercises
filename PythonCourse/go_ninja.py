"""
Вася играет в компьютерную игру про ниндзя.

На данном уровне игры ниндзя, за которого играет Вася, нужно выбраться из
глубокого ущелья.
Ущелье представляет из себя две отвесные параллельные стены. Мысленно разобьем
эти стены на участки равной длины и пронумеруем их натуральными числами от 1
до n снизу вверх. Некоторые участки обычные — по ним ниндзя может карабкаться.
Другие же покрыты шипами, и ниндзя не может на них находиться. Назовем такие
участки опасными.
Изначально нинздя находится на нижнем участке (номер 1) левой стены. Каждую 
секунду он может сделать одно из действий:
    - подняться на один участок вверх;
    - спуститься на один участок вниз;
    - перепрыгнуть на противоположную стену, при этом ниндзя оказывается на
        участке, который ровно на k участков выше того участка, с которого
        производился прыжок. То есть, если до прыжка ниндзя находился на
        участке номер x одной стены, то после прыжка, он будет находиться на
        участке номер x + k другой стены.
Если в какой-то момент времени ниндзя пытается переместиться на участок с
номером большим чем n, то считается, что ниндзя выбрался из ущелья.
Уровень считается пройденным, если ниндзя удалось выбраться из ущелья.

Входные данные
В первой строке записаны два целых числа n и k (1 ≤ n, k ≤ 50) — высота ущелья
и высота прыжка ниндзя соответственно. Во второй строке задано описание левой 
стены — строка длиной n символов. i-ый символ обозначает состояние i-го 
участка стены: символ «X» обозначает, что участок опасен, символ «-» — что нет.
В третьей строке задано описание правой стены в аналогичном формате.
Гарантируется, что первый участок левой стены не опасен.

Выходные данные
Выведите «YES» (без кавычек) если ниндзя может выбраться из ущелья или «NO»
(без кавычек) в противном случае.

Sample Input 1:
7 3
---X--X
-X--XX-

Sample Output 1:
YES

Sample Input 2:
6 2
--X-X-
XX-XX-

Sample Output 2:
NO
"""

def go_ninja(elem, marked, tmp_dict):
    marked.append(elem)
    if 'Finish' in tmp_dict[elem]:
        return True
    for e in tmp_dict[elem]:
        if e not in marked:
            if go_ninja(e, marked, tmp_dict):
                return True
    return False

def main():
    num, k = [int(i) for i in input().split()]
    wall = [input(), input()]
    tmp_dict = {}

    for i in range(2):
        for n, sym in enumerate(wall[i]):
            if sym != 'X':
                tmp_dict[(i, n)] = []

    for key, value in tmp_dict.items():
        if key[1] + k >= num:
            tmp_dict[key].append('Finish');
        else:
            if wall[int(not key[0])][key[1]+k] != 'X':
                tmp_dict[key].append((int(not key[0]), key[1]+k));
            if wall[key[0]][key[1]+1] != 'X':
                tmp_dict[key].append((key[0], key[1]+1));
            if  key[1] != 0 and (wall[key[0]][key[1]-1] != 'X'):
                tmp_dict[key].append((key[0], key[1]-1));
    marked = []
    if go_ninja((0,0), marked, tmp_dict):
        print('YES')
    else:
        print('NO')

if __name__ == "__main__":
    main()
    






